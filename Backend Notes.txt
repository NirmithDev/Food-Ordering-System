Food Ordering System Backend Notes
- Initialize the project add necessary modules from Spring Initializer
- Add database connection for MYSql and add password
- Create Model folders which will contain our table models/schema
- Create Entities commit https://github.com/NirmithDev/Food-Ordering-System/pull/7 and https://github.com/NirmithDev/Food-Ordering-System/pull/12
	- we add id for user and orders
	- we add a One to Many relationships for the user orders because a user has many orders
	- we add jsonIgnore because whenever I fetch the user I do not need this list we are isolating this because we are going to build a separate Order API to fetch all user orders
	- we create a dto package and add a Restaurant DTO what it is is essentially a data transfer object
		- we add embeddable to that class
	- we then add a list of addresses for the user class the relationship is also OneToMany
	- create the address class with the id and all as a Entity
		- we add this to it cascade = CascadeType.ALL, orphanRemoval = true because when we delete the user we want to remove all data related to him from the system
	- now we are working on Order Entity
	- we create the restaurant and userName object and assign ManyToOne relationships
	- we add items as well which include which all things user has ordered in that order
	- we add the objects for order and complete it
	- we also create a OrderItem schema which has just the id atm 
	- we then created the entities for IngredientCategory and Ingredients
	- we also created Restaurant entity
	- we also created CartItem Cart
	- we completed previous uncompleted classes such as ContactInfomation, Order, Restaurant and so on.
- Once the models were completed we added the configuration for the Spring Security
	- What we did was create a package and a file name AppConfig
	- in there we enabled security checks for authenticating based on roles provided to the users
	- we have 3 requestMatchers
		- first one is only for admin and owners
		- second one is for authentiated users only i.e. we need to provide a token 
		- last is let anyone do whatever request they want
	- we add these lines
		.addFilterBefore(new JwtTokenValidator(), BasicAuthenticationFilter.class)
                .csrf(csrf->csrf.disable())
                .cors(cors->cors.configurationSource(corsConfigurationSource()));
	- to add filter for Jwt and cors and disable csrf
	- we then implement the method for corsConfigurationSource
		- what it essentially contains is allowed methods, urls, requests, authentication tokens
	- we also create a password encoder 
		- the reason for it is when we create a new user we do not want to store a direct password into db we want to encrypt it and store it for security
	- we create the JwtTokenValidator class and use the default suggested 
	- we add the required dependencies to our pom.xml
	- we then create our JwtConstant class
		- we want to add a header and key which will be used for creating and validating jwt token
		- we check if it is valid token
		- if it is we need to extract the authorities and email for that specific user token
- we now still notice it auto generates security password and we want to prevent it from doing so
	- to do so we create service and a file called CustomerUserDetailsService	
	- in here we try to find the user email based on username 
	- if not found throw error
	- else get roles and add his authority to the granted Authority list
	- we then retun the user (spring security) output with user credentials
- we are now going to create the login and registration controller
	- we create a AuthController class and add request mapping to it
- we need to create JwtProvider
	- 2 method one to generate token and second to get email from the token
	 - to generate token
		- we first get roles and authorities and populate roles with the populateAuthorities function
			- we join the roles once we get them all in populateAuthorities
		- we then create our jwt string format with a expiration date and the 2 claims email and roles
	- to get the email we follow the same process as before using claims and jwt parseBuilder and extracting the emails
-  We are now building our AuthController for login and registration
	- We first built authresponse *this class is what we will use to generate our authentication responses 
	- we then create our AuthController class 
		- where we create our createUserHandler function which will be responsible for checking if it is a new user with a new email and we will then generate our jwt Token get his/her roles save the details using userRepository and cartRepository
		- we create our signin function which takes username and password via LoginRequest where we extract the data
		- we then authenticate and verify the user actually exists in our db
		- we then add a collection to it and then upload it
		- we then fix it up add the jwt token for validated user and send the responseEntity response
		- we are now testing the request with postman
- we added a home controller but it was only for testing purposes to view why postman refused access
- we created our UserController class for our users profile functionality
- we created User Services to find User by JwtToken and find user by email
- we created our CreateRestaurant Request which will recieve all this data from frontend
- we then create Restaurant Service and its methods 
- we create Restaurant Repository
	- Here we created the search function to find restaurants that match a search
- we then create an implementation for the restaurant service 
	- atm it is just to create a restaurant with parameters such as CreateRestaurantRequest and all we do is just send all details required when building the restaurant
	- we implement the rest of restaurant api methods based on their requirements such as updateRestaurant, deleteRestaurant, getAllRestaurants, searchRestaurant, findRestaurantById, getRestaurantByUserId, addToFavorites, updateRestaurantStatus
		- we use optional type to give us the additional features of allowing both null and not null to be passed back
	